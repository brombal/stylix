export type MapObjectFunction = (
  key: string | number,
  value: any,
  source: unknown,
  context: any,
  mapRecursive: (value: unknown) => unknown,
) => unknown;

/**
 * Returns a new object or array, generated by invoking `map` on each key-value pair in `source` and merging the returned value into
 * the result. The return value should be an object or array (to match `source`), or undefined to omit the key-value pair from the result.
 *
 * If `source` is an object, Object.assign() will be used to merge the response into the result object.
 *
 * If `source` is an array, the returned array entries will be pushed onto the result array (i.e. it will be flattened, one level deep).
 *
 * The `map` function will receive the following arguments:
 * - The current key or index
 * - The current value
 * - The current object/array being mapped
 * - A context object. This is a plain object that you can modify as needed. The value will be shallow cloned for each key, and the clone
 *   will be passed into the `mapRecursive` method in order to persist it in recursive mapping.
 * - A `mapRecursive` function that can be used to recursively map nested objects or arrays. You can call this by passing the current value,
 *   which will run the same mapping function on the value and return the result. If the value is not an object or array, it will just
 *   return the value. The mapping function will receive the context object for the current key, and any modifications made to the context
 *   object will be persisted into the recursive call. This could be used, for example, to keep track of the current depth of the recursion
 *   or the full path of the current value.
 *
 * Example:
 *
 * ```ts
 * const value = {
 *   ignoreMe: null,
 *   string: 'value',
 *   object: {
 *     a: 1,
 *     b: 2,
 *   },
 *   array: [1, 2, 3, 4],
 * }
 * const result = mapObjectRecursive(value, (key, value, source, context) => {
 *   if (key === 'ignoreMe')
 *     return undefined; // will omit key from result
 *   if (typeof key === 'string' && typeof value === 'string')
 *     return { [key]: value + '-mapped' }; // will append '-mapped' to string values
 *   if (typeof key === 'string' && typeof value === 'number')
 *     return { [key]: value, [`${key}-mapped`]: value * 2 }; // will add a new key with the value doubled
 *   if (typeof value === 'object')
 *     return { [key]: value }; // will leave object unchanged
 *   if (Array.isArray(source) && typeof value === 'number')
 *     return [value, value * 2]; // will add the value and the value doubled to the array
 * });
 * // result:
 * // {
 * //   string: 'value-mapped',
 * //   object: {
 * //     a: 1,
 * //     'a-mapped': 2,
 * //     b: 2,
 * //     'b-mapped': 4,
 * //   },
 * //   array: [1, 2, 2, 4, 3, 6, 4, 8],
 * // }
 * ```
 */
export function mapObject<TSource>(
  source: TSource,
  map: MapObjectFunction,
  context: any = {},
): TSource {
  if (typeof source !== 'object') return source;
  const result = Array.isArray(source) ? ([] as unknown[]) : ({} as Record<string, unknown>);
  for (const _key in source) {
    const key = Array.isArray(source) ? +_key : _key;
    const value = (source as any)[key];

    const contextClone = { ...context };
    const mapResult = map(key, value, source, contextClone, (value) =>
      mapObject(value, map, contextClone),
    );

    if (typeof mapResult === 'undefined') continue;

    if (Array.isArray(mapResult) && Array.isArray(source)) {
      (result as unknown[]).push(...mapResult);
      continue;
    }

    if (
      typeof mapResult === 'object' &&
      !Array.isArray(mapResult) &&
      typeof source === 'object' &&
      !Array.isArray(source)
    ) {
      Object.assign(result as object, mapResult);
      continue;
    }

    throw new Error(
      `mapObjectRecursive: return value of map function must be an object, array, or undefined, and must match the type of the source value. Type of source value was ${typeof source}, and type of returned value was ${typeof mapResult}.`,
    );
  }

  return result as TSource;
}
